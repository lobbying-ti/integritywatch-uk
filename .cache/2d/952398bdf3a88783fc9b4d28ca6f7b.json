{"id":"../node_modules/vue-hot-reload-api/dist/index.js","dependencies":[{"name":"C:\\Users\\TomWright\\PycharmProjects\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1745854459698},{"name":"C:\\Users\\TomWright\\PycharmProjects\\integritywatch-uk\\node_modules\\vue-hot-reload-api\\package.json","includedInParent":true,"mtime":1745854459515}],"generated":{"js":"var Vue // late bind\r\nvar version\r\nvar map = Object.create(null)\r\nif (typeof window !== 'undefined') {\r\n  window.__VUE_HOT_MAP__ = map\r\n}\r\nvar installed = false\r\nvar isBrowserify = false\r\nvar initHookName = 'beforeCreate'\r\n\r\nexports.install = function (vue, browserify) {\r\n  if (installed) { return }\r\n  installed = true\r\n\r\n  Vue = vue.__esModule ? vue.default : vue\r\n  version = Vue.version.split('.').map(Number)\r\n  isBrowserify = browserify\r\n\r\n  // compat with < 2.0.0-alpha.7\r\n  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {\r\n    initHookName = 'init'\r\n  }\r\n\r\n  exports.compatible = version[0] >= 2\r\n  if (!exports.compatible) {\r\n    console.warn(\r\n      '[HMR] You are using a version of vue-hot-reload-api that is ' +\r\n        'only compatible with Vue.js core ^2.0.0.'\r\n    )\r\n    return\r\n  }\r\n}\r\n\r\n/**\r\n * Create a record for a hot module, which keeps track of its constructor\r\n * and instances\r\n *\r\n * @param {String} id\r\n * @param {Object} options\r\n */\r\n\r\nexports.createRecord = function (id, options) {\r\n  if(map[id]) { return }\r\n\r\n  var Ctor = null\r\n  if (typeof options === 'function') {\r\n    Ctor = options\r\n    options = Ctor.options\r\n  }\r\n  makeOptionsHot(id, options)\r\n  map[id] = {\r\n    Ctor: Ctor,\r\n    options: options,\r\n    instances: []\r\n  }\r\n}\r\n\r\n/**\r\n * Check if module is recorded\r\n *\r\n * @param {String} id\r\n */\r\n\r\nexports.isRecorded = function (id) {\r\n  return typeof map[id] !== 'undefined'\r\n}\r\n\r\n/**\r\n * Make a Component options object hot.\r\n *\r\n * @param {String} id\r\n * @param {Object} options\r\n */\r\n\r\nfunction makeOptionsHot(id, options) {\r\n  if (options.functional) {\r\n    var render = options.render\r\n    options.render = function (h, ctx) {\r\n      var instances = map[id].instances\r\n      if (ctx && instances.indexOf(ctx.parent) < 0) {\r\n        instances.push(ctx.parent)\r\n      }\r\n      return render(h, ctx)\r\n    }\r\n  } else {\r\n    injectHook(options, initHookName, function() {\r\n      var record = map[id]\r\n      if (!record.Ctor) {\r\n        record.Ctor = this.constructor\r\n      }\r\n      record.instances.push(this)\r\n    })\r\n    injectHook(options, 'beforeDestroy', function() {\r\n      var instances = map[id].instances\r\n      instances.splice(instances.indexOf(this), 1)\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Inject a hook to a hot reloadable component so that\r\n * we can keep track of it.\r\n *\r\n * @param {Object} options\r\n * @param {String} name\r\n * @param {Function} hook\r\n */\r\n\r\nfunction injectHook(options, name, hook) {\r\n  var existing = options[name]\r\n  options[name] = existing\r\n    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]\r\n    : [hook]\r\n}\r\n\r\nfunction tryWrap(fn) {\r\n  return function (id, arg) {\r\n    try {\r\n      fn(id, arg)\r\n    } catch (e) {\r\n      console.error(e)\r\n      console.warn(\r\n        'Something went wrong during Vue component hot-reload. Full reload required.'\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateOptions (oldOptions, newOptions) {\r\n  for (var key in oldOptions) {\r\n    if (!(key in newOptions)) {\r\n      delete oldOptions[key]\r\n    }\r\n  }\r\n  for (var key$1 in newOptions) {\r\n    oldOptions[key$1] = newOptions[key$1]\r\n  }\r\n}\r\n\r\nexports.rerender = tryWrap(function (id, options) {\r\n  var record = map[id]\r\n  if (!options) {\r\n    record.instances.slice().forEach(function (instance) {\r\n      instance.$forceUpdate()\r\n    })\r\n    return\r\n  }\r\n  if (typeof options === 'function') {\r\n    options = options.options\r\n  }\r\n  if (record.Ctor) {\r\n    record.Ctor.options.render = options.render\r\n    record.Ctor.options.staticRenderFns = options.staticRenderFns\r\n    record.instances.slice().forEach(function (instance) {\r\n      instance.$options.render = options.render\r\n      instance.$options.staticRenderFns = options.staticRenderFns\r\n      // reset static trees\r\n      // pre 2.5, all static trees are cached together on the instance\r\n      if (instance._staticTrees) {\r\n        instance._staticTrees = []\r\n      }\r\n      // 2.5.0\r\n      if (Array.isArray(record.Ctor.options.cached)) {\r\n        record.Ctor.options.cached = []\r\n      }\r\n      // 2.5.3\r\n      if (Array.isArray(instance.$options.cached)) {\r\n        instance.$options.cached = []\r\n      }\r\n\r\n      // post 2.5.4: v-once trees are cached on instance._staticTrees.\r\n      // Pure static trees are cached on the staticRenderFns array\r\n      // (both already reset above)\r\n\r\n      // 2.6: temporarily mark rendered scoped slots as unstable so that\r\n      // child components can be forced to update\r\n      var restore = patchScopedSlots(instance)\r\n      instance.$forceUpdate()\r\n      instance.$nextTick(restore)\r\n    })\r\n  } else {\r\n    // functional or no instance created yet\r\n    record.options.render = options.render\r\n    record.options.staticRenderFns = options.staticRenderFns\r\n\r\n    // handle functional component re-render\r\n    if (record.options.functional) {\r\n      // rerender with full options\r\n      if (Object.keys(options).length > 2) {\r\n        updateOptions(record.options, options)\r\n      } else {\r\n        // template-only rerender.\r\n        // need to inject the style injection code for CSS modules\r\n        // to work properly.\r\n        var injectStyles = record.options._injectStyles\r\n        if (injectStyles) {\r\n          var render = options.render\r\n          record.options.render = function (h, ctx) {\r\n            injectStyles.call(ctx)\r\n            return render(h, ctx)\r\n          }\r\n        }\r\n      }\r\n      record.options._Ctor = null\r\n      // 2.5.3\r\n      if (Array.isArray(record.options.cached)) {\r\n        record.options.cached = []\r\n      }\r\n      record.instances.slice().forEach(function (instance) {\r\n        instance.$forceUpdate()\r\n      })\r\n    }\r\n  }\r\n})\r\n\r\nexports.reload = tryWrap(function (id, options) {\r\n  var record = map[id]\r\n  if (options) {\r\n    if (typeof options === 'function') {\r\n      options = options.options\r\n    }\r\n    makeOptionsHot(id, options)\r\n    if (record.Ctor) {\r\n      if (version[1] < 2) {\r\n        // preserve pre 2.2 behavior for global mixin handling\r\n        record.Ctor.extendOptions = options\r\n      }\r\n      var newCtor = record.Ctor.super.extend(options)\r\n      // prevent record.options._Ctor from being overwritten accidentally\r\n      newCtor.options._Ctor = record.options._Ctor\r\n      record.Ctor.options = newCtor.options\r\n      record.Ctor.cid = newCtor.cid\r\n      record.Ctor.prototype = newCtor.prototype\r\n      if (newCtor.release) {\r\n        // temporary global mixin strategy used in < 2.0.0-alpha.6\r\n        newCtor.release()\r\n      }\r\n    } else {\r\n      updateOptions(record.options, options)\r\n    }\r\n  }\r\n  record.instances.slice().forEach(function (instance) {\r\n    if (instance.$vnode && instance.$vnode.context) {\r\n      instance.$vnode.context.$forceUpdate()\r\n    } else {\r\n      console.warn(\r\n        'Root or manually mounted instance modified. Full reload required.'\r\n      )\r\n    }\r\n  })\r\n})\r\n\r\n// 2.6 optimizes template-compiled scoped slots and skips updates if child\r\n// only uses scoped slots. We need to patch the scoped slots resolving helper\r\n// to temporarily mark all scoped slots as unstable in order to force child\r\n// updates.\r\nfunction patchScopedSlots (instance) {\r\n  if (!instance._u) { return }\r\n  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js\r\n  var original = instance._u\r\n  instance._u = function (slots) {\r\n    try {\r\n      // 2.6.4 ~ 2.6.6\r\n      return original(slots, true)\r\n    } catch (e) {\r\n      // 2.5 / >= 2.6.7\r\n      return original(slots, null, true)\r\n    }\r\n  }\r\n  return function () {\r\n    instance._u = original\r\n  }\r\n}\r\n"},"sourceMaps":null,"error":null,"hash":"44f3f978dc1bfc936f9186947905d389","cacheData":{"env":{}}}