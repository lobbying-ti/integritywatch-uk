{"id":"../node_modules/d3-scale/src/sequentialQuantile.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1701204570000},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\package.json","includedInParent":true,"mtime":1710515718187},{"name":"d3-array","loc":{"line":1,"column":32,"index":32},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\src\\sequentialQuantile.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-array\\src\\index.js"},{"name":"./continuous","loc":{"line":2,"column":23,"index":67},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\src\\sequentialQuantile.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\src\\continuous.js"},{"name":"./init","loc":{"line":3,"column":31,"index":114},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\src\\sequentialQuantile.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-scale\\src\\init.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sequentialQuantile;\nvar _d3Array = require(\"d3-array\");\nvar _continuous = require(\"./continuous\");\nvar _init = require(\"./init\");\nfunction sequentialQuantile() {\n  var domain = [],\n    interpolator = _continuous.identity;\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator(((0, _d3Array.bisect)(domain, x) - 1) / (domain.length - 1));\n  }\n  scale.domain = function (_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(_d3Array.ascending);\n    return scale;\n  };\n  scale.interpolator = function (_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n  scale.copy = function () {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n  return _init.initInterpolator.apply(scale, arguments);\n}"},"sourceMaps":null,"error":null,"hash":"e59eb97ac535c790484ff65162d27eff","cacheData":{"env":{}}}