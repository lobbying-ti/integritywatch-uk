{"id":"../node_modules/crossfilter2/src/array.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1715768641465},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\crossfilter2\\package.json","includedInParent":true,"mtime":1711627384248}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nlet array8 = arrayUntyped,\n  array16 = arrayUntyped,\n  array32 = arrayUntyped,\n  arrayLengthen = arrayLengthenUntyped,\n  arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function (n) {\n    return new Uint8Array(n);\n  };\n  array16 = function (n) {\n    return new Uint16Array(n);\n  };\n  array32 = function (n) {\n    return new Uint32Array(n);\n  };\n  arrayLengthen = function (array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n  arrayWiden = function (array, width) {\n    var copy;\n    switch (width) {\n      case 16:\n        copy = array16(array.length);\n        break;\n      case 32:\n        copy = array32(array.length);\n        break;\n      default:\n        throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\nfunction arrayUntyped(n) {\n  var array = new Array(n),\n    i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  };\n  this[0] = array8(n);\n}\nbitarray.prototype.lengthen = function (n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function () {\n  var m, w, one, i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - 32 * i;\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & m + 1) >>> 0;\n    if (w >= 32 && !one) {\n      continue;\n    }\n    if (w < 32 && one & 1 << w) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n    this.masks[i] |= one;\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function (dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function (n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function (n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function (n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function (n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function (n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function (n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset) mask &= zero;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar _default = exports.default = {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};"},"sourceMaps":null,"error":null,"hash":"1273fbc401a650f38c50ead0e0ff887d","cacheData":{"env":{}}}