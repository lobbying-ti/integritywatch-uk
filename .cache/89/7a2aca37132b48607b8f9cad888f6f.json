{"id":"../node_modules/crossfilter2/src/heap.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1715768641465},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\crossfilter2\\package.json","includedInParent":true,"mtime":1711627384248},{"name":"./identity","loc":{"line":1,"column":21,"index":21},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\crossfilter2\\src\\heap.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\crossfilter2\\src\\identity.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _identity = _interopRequireDefault(require(\"./identity\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction heap_by(f) {\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n      i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n      t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n      x = f(d),\n      child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n  heap.sort = sort;\n  return heap;\n}\nconst h = heap_by(_identity.default);\nh.by = heap_by;\nvar _default = exports.default = h;"},"sourceMaps":null,"error":null,"hash":"f9816d91cb364474261ca2e67289ce04","cacheData":{"env":{}}}